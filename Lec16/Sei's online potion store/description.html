<h3>Description</h3>
<div>
<p>Sei is a researcher at the Medicinal Flora Research Institute. She has been work there for a year and is struggling to improve her KPI. One day she finds out that she can sell potions online to improve her poor KPI (?. After several days of hard working, she has finished a framework of the ordering system, there are only two little functions that aims to calculate the total cost of orders and reordering the orders gaps her from finish, please help her to fulfill those functions.</p><p>She currently sells 15 potion products over the online shop that are given name <code>Prod_A, Prod_B ..., Prod_O</code>, each product costs differently, the information could be found in the finished part (loader code) of the platform. You do not need to concern the orders with the same pick up time.<img src="https://64.media.tumblr.com/a527a758b1d7ad5b066382dd1e879acb/da9735baa45d502a-9e/s400x600/39963fb633c270428befd5937883837e6ae46561.gifv"></p>
</div>
<p></p>
<h3>Input</h3>
The first line contains an integer N that indicates the number of orders which followed by the detail of N orders.
For each order, the order ID comes first, then the pick up time of the order which followed by the item count M of the order, finally M items and the count are given.
<p></p>
<h3>Output</h3>
The order ID and the total cost of the orders, the order that has a closer pick up time comes first.
<p></p>
<h3>Loader Code</h3>
<div>
<p>Your code will be judge using this program:</p>
</div>
<pre>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    unsigned char hour;
    unsigned char minute;
} hm_t;

typedef struct {
    const char *item_name;
    unsigned cost;
    unsigned cnt;
} item_t;

typedef struct {
    unsigned order_id;
    hm_t pick_up_time;
    unsigned total_cost;
    unsigned item_cnt;
    item_t *items;
} order_t;

const item_t avaliable_items[] = {
    {"Prod_A",  10},
    {"Prod_B",  20},
    {"Prod_C",  15},
    {"Prod_D",  30},
    {"Prod_E",  50},
    {"Prod_F",  60},
    {"Prod_G",  75},
    {"Prod_H",   5},
    {"Prod_I",  25},
    {"Prod_J",  80},
    {"Prod_K", 100},
    {"Prod_L",  90},
    {"Prod_M",  45},
    {"Prod_N",  40},
    {"Prod_O",  85},
};

const unsigned avaliable_item_cnt = 15;
#define MAX_ORDER_CNT 1024

unsigned fetch_orders(order_t orders[]);
void sum_total_costs(order_t orders[], unsigned order_cnt);
void reorder(order_t orders[], unsigned order_cnt);
void print_result(order_t orders[], unsigned order_cnt);
void clean_up(order_t orders[], unsigned order_cnt);

int main()
{
    order_t orders[MAX_ORDER_CNT];
    unsigned order_cnt = fetch_orders(orders);
    sum_total_costs(orders, order_cnt);
    reorder(orders, order_cnt);
    print_result(orders, order_cnt);
    clean_up(orders, order_cnt);
    return 0;
}

unsigned fetch_orders(order_t orders[])
{
    unsigned order_cnt;
    scanf("%u", &order_cnt);

    // Prepare the orders.
    order_t *curr = orders;
    for (unsigned i = 0; i < order_cnt; i++, curr++) {
        hm_t *curr_pu = &(curr->pick_up_time);
        scanf("%u %hhu:%hhu %u",
                                &(curr->order_id),
                                &(curr_pu->hour),
                                &(curr_pu->minute),
                                &(curr->item_cnt));

        // Create a variable length array with malloc.
        item_t *curr_items = curr->items = malloc(sizeof(item_t) * curr->item_cnt);
        for (unsigned j = 0; j < curr->item_cnt; j++) {
            char item_name[32];
            scanf("%s", item_name);
            for (unsigned k = 0; k < avaliable_item_cnt; k++) {
                if (!strcmp(item_name, avaliable_items[k].item_name)) {
                    // Copy the memory content from avaliable_items to curr_items.
                    curr_items[j] = avaliable_items[k];
                    break;
                }
            }
            scanf("%u", &(curr_items[j].cnt));
        }
    }
    return order_cnt;
}

void print_result(order_t orders[], unsigned order_cnt)
{
    for (unsigned i = 0; i < order_cnt; i++) {
        printf("#%u %u\n", orders[i].order_id, orders[i].total_cost);
    }
}

void clean_up(order_t orders[], unsigned order_cnt)
{
    for (unsigned i = 0; i < order_cnt; i++) {
        free(orders[i].items);
    }
}
</pre>
